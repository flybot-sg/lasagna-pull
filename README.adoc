= Pullable, precisely select from deep data structure.

image:https://github.com/flybot-sg/lasagna-pull/workflows/CI/badge.svg[CI]
image:https://codecov.io/gh/flybot-sg/lasagna-pull/branch/master/graph/badge.svg[codecov,link=https://codecov.io/gh/flybot-sg/lasagna-pull]
image:https://img.shields.io/clojars/v/sg.flybot/lasagna-pull.svg[clojars,link=https://clojars.org/sg.flybot/lasagna-pull]
image:https://cljdoc.org/badge/sg.flybot/lasagna-pull[cljdoc,link=https://cljdoc.org/d/sg.flybot/lasagna-pull]

== Rational

Maps and collections are butter and bread in Clojure, and we store all kinds of data. Therefore, getting data (aka query) is very important, and `get-in` and `select-keys` are very common in our code.

However, if maps are deeply nested, this approach becomes cumbersome. Some excellent libraries are trying to make it easy, like https://github.com/redplanetlabs/specter[Specter] and https://docs.datomic.com/on-prem/query/pull.html[Datomic pull API].

Lasagna-pull's `query` turns a query pattern (a kind of data structure) into a function:

[source,clojure]
----
(require '[sg.flybot.pullable :refer [query]])

(def my-query (query '{:a ? :b {:c ?}}))

(my-query {:a 3 :d 5 :b {:e {:f :something} :c "Hello"}}) ;=> [{:a 3 :b {:c "Hello"}} {}]
----

The design purposes of the pulling pattern are:

 - Pure Clojure data structure.
 - Similar to the data structure which you are going to query. You could think of it as an example.

== Core Functions

 - `query`: Returns a query function that can query data.
 
 Run query against data returns a pair of resulting data and a context map containing named bindings.

 - If there are no matches, the resulting data will be `nil`

== Data error

If running a pattern for given `data` encounters unexpected data, it will not throw exceptions. A particular error data will be generated in place instead. 

[source,clojure]
----
((query '{:a ?}) 3) ;=> {:a #error{...}}
----

== Query pattern

Generally, query patterns have the same structure as your data; where there is a map, you use a map in place of it; where there is a sequence (vector, list, etc.) of maps, you use a vector in place.

You mark the data you are interested in by a special `'?`, so:

[source,clojure]
----
((query '{:a ?,:b ?}) {:a 1, :b 2, :c 3}) ;=> [{:a 1, :b 2} {}]
----

This works just like `select-keys` only query patterns look like an example, but why is the returned value a pair of maps here?

Because query patterns also support logical variables, which is a symbol starting with `?`, `query` returns the matched data and a logical variable map, let's try:

[source,clojure]
----
((query '{:a ?a, :b ?b}) {:a 1, :b 2, :c 3}) ;=> [{:a 1, :b 2} {'?a 1 '?b 2}]
----

If a value in a map is a function, it becomes a filter, a match will only happen when the target value fulfills it.

A non-function value like `2`, `:ok` is a shortcut of `#(= % 2)`.

[source,clojure]
----
((query {:a '?, :b odd?}) {:a 1, :b 1}) ;=> [{:a 1} {}]
((query {:a '?, :b 2}) {:a 1, :b 2}) ;=> [{:a 1} {}]
((query {:a '?, :b 2}) {:a 1, :b 1}) ;=> [nil {}] ;; value of :b does not match pattern
----

and if a logical variable is bound more than one time, it must match the same value, otherwise, it fails every match.

[source,clojure]
----
((query {:a '?x, :b '?x}) {:a 2, :b 2}) ;=> [{:a 2, :b 2} {'?x 2}]
((query {:a '?x, :b '?x}) {:a 2, :b 1}) ;=> [nil {}]
----

Nested data can be matched by nested pattern:

[source,clojure]
----
((query {:a {:b '?b} :c {:d {:e '?e}}}) {:a {:b 3} :c {:d {:e 5}}}) ;=> [{:a {:b 3}, :c {:d {:e 5}}} {?b 3, ?e 5}]
----

=== sequence of maps

To match a sequence of maps, using `[]` to surround it:

[source,clojure]
----
((query [{:a '?}]) [{:a 3, :b 4} {:a 1} {}]) ;=> [[{:a 3} {:a 1} {}], {}]
----

Put logical variable after this single inner map, binding it to the whole sequence:

[source,clojure]
----
((query [{:a '?} '?x]) [{:a 3, :b 4} {:a 1} {}]) ;=> [[{:a 3} {:a 1} {}] {?x [{:a 3} {:a 1} {}]}]
----

== Advanced query options

Patterns can have options and surround a key in a list, the following pairs are query options.

=== `:not-found` option

When a key is not present in a map, a `not-found` value will be used instead.

[source,clojure]
----
((query {'(:a :not-found ::not-found) '?}) {:b 5}) ;=> [{:a ::not-found} {}]
----

=== `:when` option

[source,clojure]
----
((query {(list :a :when even?) '?}) {:a 6}) ;=> [{:a 6} {}]
((query {(list :a :when even?) '?}) {:a 5}) ;=> [{} {}] ;;not found because the value is not even
----

=== `:with` option and `:batch` option

If the value of a key is a function, using `:with` option can invoke it and returns the result instead. This option paves the way for mutation like in GraphQL.

[source,clojure]
----
((query '{(:a :with [5]) ?}) {:a #(* % 2)}) ;=> [{:a 10} {}]
----

You can invoke the value function multiple times by using a `:batch` option:

[source,clojure]
----
((query '{(:a :batch [[5] [7]]) ?}) {:a #(* % 2)}) => [{:a [10 14]} {}]
----

These options can be nested if they return a map or a sequence of maps:

[source,clojure]
----
((query '{(:a :with [5]) {:b ?}}) {:a (fn [x] {:b (* x x)})}) ;=> [{:a {:b 25}} {}]
((query '{(:a :batch [[1] [2] [3]]) [{:b ?}]}) {:a (fn [x] {:b (* x x)})}) ;=> [{:a [{:b 1} {:b 4} {:b 9}]} {}]
----

=== `:seq` option for pagination

The value of this option is a vector of non-negative integers meaning starting index and number of items respectively. It can only be applied to a sequence value.

[source,clojure]
----
((query '[{:a ? :b ?} ? :seq [2 3]]) [{:a 0} {:a 1} {:a 2} {:a 3} {:a 4}]) ;=> [[{:a 2} {:a 3} {:a 4}] {}]
----

== License
Copyright. Â© 2022 Flybot Pte. Ltd.
Apache License 2.0, http://www.apache.org/licenses/
